/**
 * Audit Logger - Tracks user actions for security and compliance
 */

import { executeQuery } from './database';

export interface AuditLog {
  user_id?: number;
  action: string;
  resource: string; // Keep in interface for backward compatibility, maps to resource_type in DB
  resource_id?: number;
  details?: string;
  ip_address?: string;
  user_agent?: string;
  status: 'success' | 'failure';
  error_message?: string;
}

/**
 * Log an audit event to the database
 */
export async function logAuditEvent(log: AuditLog): Promise<void> {
  try {
    // Check if audit_logs table exists, if not, create it
    try {
        await executeQuery(
          `BEGIN
             EXECUTE IMMEDIATE 'CREATE TABLE audit_logs (
               id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
               user_id NUMBER,
               action VARCHAR2(100) NOT NULL,
               resource_type VARCHAR2(100) NOT NULL,
               resource_id NUMBER,
               details CLOB,
               ip_address VARCHAR2(45),
               user_agent VARCHAR2(500),
               status VARCHAR2(20) NOT NULL,
               error_message VARCHAR2(1000),
               created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
             )';
           EXCEPTION
             WHEN OTHERS THEN
               IF SQLCODE != -955 THEN -- Table already exists
                 RAISE;
               END IF;
           END;`
        );
      
      if (process.env.NODE_ENV === 'development') {
        console.log('✅ Audit logs table created or already exists');
      }
    } catch (createError) {
      // Table might already exist, that's okay
      if (process.env.NODE_ENV === 'development') {
        console.log('ℹ️ Audit logs table check:', createError instanceof Error ? createError.message : 'Unknown');
      }
    }

    // Insert audit log (resource maps to resource_type in database)
    // Ensure resource_id is a number or null
    const resourceId = log.resource_id !== undefined && log.resource_id !== null
      ? Number(log.resource_id)
      : null;

    const result = await executeQuery(
      `INSERT INTO audit_logs (
        user_id, action, resource_type, resource_id, details, 
        ip_address, user_agent, status, error_message
      ) VALUES (
        :user_id, :action, :resource_type, :resource_id, :details,
        :ip_address, :user_agent, :status, :error_message
      )`,
      {
        user_id: log.user_id !== undefined && log.user_id !== null ? Number(log.user_id) : null,
        action: log.action,
        resource_type: log.resource, // Map resource to resource_type
        resource_id: resourceId,
        details: log.details || null,
        ip_address: log.ip_address || null,
        user_agent: log.user_agent || null,
        status: log.status,
        error_message: log.error_message || null,
      }
    );

    if (process.env.NODE_ENV === 'development') {
      console.log('✅ Audit log recorded:', {
        action: log.action,
        resource_type: log.resource,
        resource_id: resourceId,
        user_id: log.user_id,
        status: log.status,
        rowsAffected: result.rowsAffected,
      });
    }
  } catch (error) {
    // Don't throw error - audit logging should not break the application
    // In production, you might want to log to a separate service
    console.error('❌ Failed to log audit event:', error);
    if (error instanceof Error) {
      console.error('Error details:', {
        message: error.message,
        stack: error.stack,
        logData: log,
      });
    }
  }
}

/**
 * Get audit logs for a user
 */
export async function getAuditLogs(
  userId?: number,
  limit: number = 100
): Promise<AuditLog[]> {
  try {
    const query = userId
      ? `SELECT * FROM audit_logs 
         WHERE user_id = :userId 
         ORDER BY created_at DESC 
         FETCH FIRST :limit ROWS ONLY`
      : `SELECT * FROM audit_logs 
         ORDER BY created_at DESC 
         FETCH FIRST :limit ROWS ONLY`;

    const result = await executeQuery<{
      id: number;
      user_id: number | null;
      action: string;
      resource_type: string; // Changed from resource to resource_type
      resource_id: number | null;
      details: string | null;
      ip_address: string | null;
      user_agent: string | null;
      status: string;
      error_message: string | null;
      created_at: Date;
    }>(query, {
      userId: userId || null,
      limit,
    });

    return result.rows.map((row) => ({
      user_id: row.user_id || undefined,
      action: row.action,
      resource: row.resource_type, // Map resource_type back to resource in interface
      resource_id: row.resource_id || undefined,
      details: row.details || undefined,
      ip_address: row.ip_address || undefined,
      user_agent: row.user_agent || undefined,
      status: row.status as 'success' | 'failure',
      error_message: row.error_message || undefined,
    }));
  } catch (error) {
    console.error('Failed to get audit logs:', error);
    return [];
  }
}

